
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tasmanian Ecosystem Simulator</title>
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600&family=Arial&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    /* Modern Ecosystem Simulator CSS */
    :root {
      --primary-color: #4a8fe7;
      --secondary-color: #44c767;
      --danger-color: #e74c3c;
      --warning-color: #f39c12;
      --success-color: #2ecc71;
      --dark-color: #2c3e50;
      --light-color: #ecf0f1;
      --gray-color: #95a5a6;
      --text-color: #333;
      --text-light: #7f8c8d;
      --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      --transition: all 0.3s ease;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Poppins', sans-serif;
      color: var(--text-color);
      background-color: #f5f7fa;
      line-height: 1.6;
      padding: 20px;
    }

    h1 {
      font-size: 24px;
      margin-bottom: 20px;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .points-display, .objectives-display {
      margin: 10px 0;
      font-weight: 500;
    }

    #ecosystemHealth {
      font-weight: bold;
      margin: 10px 0;
      padding: 5px 10px;
      border-radius: 4px;
      display: inline-block;
    }

    #rangerBadge {
      background-color: #fffacd;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      border: 1px solid gold;
    }

    .controls {
      background-color: white;
      padding: 15px;
      border-radius: 8px;
      box-shadow: var(--shadow);
      margin: 20px 0;
    }

    .control-group {
      margin-bottom: 15px;
    }

    .control-group label {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .control-group input[type="range"] {
      flex-grow: 1;
    }

    .slider-value {
      min-width: 30px;
      text-align: right;
    }

    button {
      padding: 8px 15px;
      background-color: var(--primary-color);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-right: 10px;
      margin-bottom: 10px;
    }

    button:hover {
      opacity: 0.9;
    }

    #canvas-container {
      width: 800px;
      height: 400px;
      margin: 20px 0;
      border-radius: 8px;
      overflow: hidden;
      box-shadow: var(--shadow);
    }

    #disasterMessage {
      display: none;
      padding: 10px 15px;
      background-color: var(--danger-color);
      color: white;
      border-radius: 4px;
      margin: 10px 0;
      transition: var(--transition);
    }

    #seasonDisplay {
      font-weight: 500;
      margin: 10px 0;
    }

    .speed-control-container {
      margin: 15px 0;
    }

    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .toggle-container {
      margin: 10px 0;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    #populationChart {
      width: 800px;
      height: 400px;
      margin: 20px 0;
      background-color: white;
      border-radius: 8px;
      box-shadow: var(--shadow);
    }

    .legend {
      display: flex;
      gap: 15px;
      margin: 10px 0;
    }

    .legend-color {
      display: inline-block;
      width: 15px;
      height: 15px;
      border-radius: 3px;
      margin-right: 5px;
    }

    .collapsible {
      background-color: #eee;
      color: #444;
      cursor: pointer;
      padding: 10px;
      width: 100%;
      border: none;
      text-align: left;
      outline: none;
      font-size: 15px;
      margin: 10px 0 0;
      border-radius: 4px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .collapsible:hover {
      background-color: #ddd;
    }

    .content {
      padding: 0 18px;
      display: none;
      overflow: hidden;
      background-color: white;
      margin-bottom: 20px;
      border-radius: 0 0 4px 4px;
      box-shadow: var(--shadow);
    }

    .left-align {
      text-align: left;
    }

    .achievement-message {
      background-color: #e8f5e9;
      padding: 8px 12px;
      border-radius: 4px;
      margin: 5px 0;
      transition: var(--transition);
    }

    .narrative-message {
      position: fixed;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: var(--dark-color);
      color: white;
      padding: 10px 20px;
      border-radius: 20px;
      z-index: 1000;
      box-shadow: var(--shadow);
      transition: var(--transition);
    }

    footer {
      margin-top: 30px;
      text-align: center;
      color: var(--text-light);
      font-size: 14px;
    }

    @media (max-width: 900px) {
      #canvas-container, #populationChart {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <h1>Tasmanian Ecosystem Simulator üåø</h1>
  <div id="medalIcon">üéñÔ∏è</div>
  <div class="points-display">Points: <span id="pointsDisplay">0</span></div>
  <div class="objectives-display">Objective: <span id="objectiveDisplay">Increase pademelon population to 100</span></div>
  <div id="ecosystemHealth">Health: HEALTHY</div>
  <div id="rangerBadge" style="display: none;">
    <p>üéñÔ∏è Congratulations! You've earned the Ranger Badge!</p>
    <div id="achievementsContainer"></div>
  </div>
  
  <div class="controls">
    <div class="control-group">
      <label>Rainfall: <input type="range" min="0" max="100" value="50" id="rainfall"> <span id="rainfallValue" class="slider-value">50</span></label>
    </div>
    <div class="control-group">
      <label>Temperature: <input type="range" min="0" max="50" value="25" id="temperature"> <span id="temperatureValue" class="slider-value">25</span></label>
    </div>
    <div class="control-group">
      <label>Invasive Species: <input type="range" min="0" max="20" value="5" id="invasiveSpecies"> <span id="invasiveSpeciesValue" class="slider-value">5</span></label>
    </div>
    <div class="control-group">
      <label>Human Impact: <input type="range" min="0" max="10" value="2" id="humanImpact"> <span id="humanImpactValue" class="slider-value">2</span></label>
    </div>
    <button id="resetButton">Reset</button>
    <button id="exportCSV">Export CSV</button>
    <button id="pauseButton">Pause</button>
    <button id="toggleGrassLimitButton">Disable Grass Limit</button>
  </div>
  
  <div id="canvas-container"></div>
  <div id="disasterMessage">Natural Disaster Occurred!</div>
  <div id="seasonDisplay">Season: Spring</div>
  
  <div class="speed-control-container">
    <div class="speed-control">
      <label for="speedSlider">Simulation Speed:</label>
      <input type="range" id="speedSlider" min="0.1" max="5" step="0.1" value="1">
      <span id="speedValue">1x</span>
    </div>
  </div>
  
  <div class="toggle-container">
    <label for="toggleSeasons">Toggle Seasons Display</label>
    <input type="checkbox" id="toggleSeasons" checked>
  </div>
  <div class="toggle-container">
    <label for="toggleDisasters">Toggle Natural Disasters</label>
    <input type="checkbox" id="toggleDisasters" checked>
  </div>
  
  <canvas id="populationChart" width="800" height="400"></canvas>
  
  <div class="legend">
    <div><span class="legend-color" style="background-color: #d4f1f4;"></span>Spring</div>
    <div><span class="legend-color" style="background-color: #f7d794;"></span>Summer</div>
    <div><span class="legend-color" style="background-color: #f5cd79;"></span>Autumn</div>
    <div><span class="legend-color" style="background-color: #c8d6e5;"></span>Winter</div>
  </div>
  
  <button class="collapsible" aria-expanded="false">Species Information <span class="arrow">&#9654;</span></button>
  <div class="content">
    <div id="info-panels">
      <h2>Species Information</h2>
      <div id="grass-info">
        <h3>Grass</h3>
        <p>Grass is the primary producer in the ecosystem, providing food for herbivores like pademelons.</p>
      </div>
      <div id="pademelons-info">
        <h3>Pademelons</h3>
        <p>Pademelons are herbivores that feed on grass and are prey for Tasmanian devils.</p>
      </div>
      <div id="devils-info">
        <h3>Tasmanian Devils</h3>
        <p>Tasmanian devils are the apex predators in this ecosystem, feeding on pademelons.</p>
      </div>
      <div id="bandicoots-info">
        <h3>Bandicoots</h3>
        <p>Bandicoots are keystone species that improve grass growth and are affected by devils and invasive species.</p>
      </div>
    </div>
  </div>
  
  <button class="collapsible" aria-expanded="false">Quizzes <span class="arrow">&#9654;</span></button>
  <div class="content">
    <div id="quizzes">
      <h2>Quizzes</h2>
      <p>Test your understanding of the ecosystem dynamics with these questions:</p>
      <div id="quiz1">
        <h3>Quiz 1</h3>
        <p>What happens to the pademelon population if the grass population decreases significantly?</p>
        <button class="quiz-btn" onclick="showAnswer('quiz1-answer')">Show Answer</button>
        <p id="quiz1-answer" style="display:none;">The pademelon population will decrease because they rely on grass as their primary food source.</p>
      </div>
      <div id="quiz2">
        <h3>Quiz 2</h3>
        <p>How does an increase in temperature affect the Tasmanian devil population?</p>
        <button class="quiz-btn" onclick="showAnswer('quiz2-answer')">Show Answer</button>
        <p id="quiz2-answer" style="display:none;">An increase in temperature can negatively affect the Tasmanian devil population by reducing their prey availability and increasing stress.</p>
      </div>
      <div id="quiz3">
        <h3>Quiz 3</h3>
        <p>What role do bandicoots play in promoting grass growth, and how does this benefit the ecosystem as a whole?</p>
        <button class="quiz-btn" onclick="showAnswer('quiz3-answer')">Show Answer</button>
        <p id="quiz3-answer" style="display:none;">Bandicoots improve soil aeration, which helps grass grow more robustly. This benefits herbivores like pademelons, leading to a healthier and more balanced ecosystem.</p>
      </div>
    </div>
  </div>
  
  <button class="collapsible" aria-expanded="false">Interconnectedness of Ecosystems <span class="arrow">&#9654;</span></button>
  <div class="content left-align">
    <div id="ecosystem-info">
      <h2>Interconnectedness of Ecosystems</h2>
      <p>Understanding the interconnectedness of ecosystems is crucial for appreciating the balance of nature. Here are a few key points:</p>
      <ul>
        <li><strong>Food Webs:</strong> All species are part of a complex food web. Changes in one population can ripple through the entire ecosystem.</li>
        <li><strong>Energy Flow:</strong> Energy flows from producers (like grass) to consumers (like pademelons and devils). Disruptions at any level affect the entire system.</li>
        <li><strong>Habitat Interdependence:</strong> Different species rely on each other for habitat and resources. Loss of one species can lead to habitat changes that affect others.</li>
        <li><strong>Human Impact:</strong> Human activities can have significant effects on ecosystems, from pollution to habitat destruction. Understanding these impacts is key to conservation.</li>
        <li><strong>Climate Change:</strong> Changes in climate can alter ecosystems, affecting species distributions and interactions. Studying these changes helps predict future impacts.</li>
      </ul>
    </div>
  </div>

  <script>
    // Tasmanian Ecosystem Simulator - Enhanced Version
    let grass, pademelons, devils, bandicoots, chart;
    let season = 0; // 0: Spring, 1: Summer, 2: Autumn, 3: Winter
    let seasonDuration = 300;
    let showSeasons = true;
    let showDisasters = true;
    let disasterDuration = 100;
    let disasterFrame = -disasterDuration;
    let isPaused = false;
    let grassLimitEnabled = true;
    let points = 0;
    let stabilityCheckFrames = 0;
    const stabilityThreshold = 1000;
    const stabilityPoints = 50;
    const rangerBadgePoints = 1500;
    let rangerBadgeAchieved = false;
    let rangerBadgeMessageShown = false;

    // Speed control
    let speedMultiplier = 1;
    let lastFrameTime = performance.now();
    let customFrameCount = 0;

    // Ecological metrics
    let biodiversityIndex = 0;
    let ecosystemHealth = 100;
    let maxGrass = 0;
    let maxPademelons = 0;
    let maxDevils = 0;
    let maxBandicoots = 0;

    // Learning objectives
    let objectives = [
      { description: "Increase pademelon population to 200", target: 200, achieved: false, points: 200, type: "pademelons" },
      { description: "Maintain devil population > 100 with grass > 400", target: 100, achieved: false, points: 300, type: "apex_stability" },
      { description: "Trigger bandicoot-driven grass recovery (50% increase)", target: 1.5, achieved: false, points: 200, type: "keystone_effect" },
      { description: "Survive 8 natural disasters", target: 8, achieved: false, points: 100, count: 0, type: "disasters" },
      { description: "Maintain biodiversity index > 0.7 for 1000 frames", target: 1000, achieved: false, points: 150, type: "biodiversity" }
    ];

    let ongoingObjectives = [
      { description: "Keep grass population > 700 for 800 frames", target: 800, achieved: false, points: 300, type: "grass", condition: (g) => g > 700 },
      { description: "Keep devil population > 70 for 800 frames", target: 800, achieved: false, points: 300, type: "devils", condition: (d) => d > 70 },
      { description: "Maintain balanced ecosystem for 1500 frames", target: 1500, achieved: false, points: 500, type: "balanced", 
        condition: (g, p, d, b) => g > 500 && p > 100 && d > 50 && b > 100 }
    ];

    let achievements = [
      { description: "Ecosystem Guardian: Achieve all ongoing objectives", achieved: false, points: 500 },
      { description: "Devil Advocate: Maintain healthy devil population for 5000 frames", achieved: false, frames: 0, target: 5000, points: 300 },
      { description: "Keystone Keeper: Double bandicoot population from starting value", achieved: false, target: 60, points: 200 }
    ];

    let populationHistory = [];
    const historyLength = 200;

    // Seasonal parameters
    let seasonParams = [
      { name: "Spring", rainfall: 70, temperature: 20, color: "#d4f1f4" },
      { name: "Summer", rainfall: 30, temperature: 35, color: "#f7d794" },
      { name: "Autumn", rainfall: 50, temperature: 15, color: "#f5cd79" },
      { name: "Winter", rainfall: 40, temperature: 5, color: "#c8d6e5" }
    ];

    // Interpolation variables
    let targetRainfall, targetTemperature;
    let currentRainfall, currentTemperature;
    const interpolationSpeed = 0.01;

    // P5.js sketch
    const sketch = (p) => {
      p.setup = () => {
        let canvas = p.createCanvas(800, 400);
        canvas.parent("canvas-container");
        
        // Initialize chart
        initChart();
        
        // Set up controls
        initControls();
        
        resetSim();
        
        // Start game loop
        requestAnimationFrame(gameLoop);
      };

      p.draw = () => {
        if (isPaused) return;
        
        // Background with seasonal colors
        p.background(showSeasons ? seasonParams[season].color : 240);
        
        // Draw ecosystem visualization
        drawEcosystem();
        
        // Update UI
        updateUI();
      };

      function drawEcosystem() {
        // Draw food web connections
        drawFoodWeb();
        
        // Draw population indicators
        drawPopulationIndicator(200, p.height/2, grass, "#4CAF50", "Grass");
        drawPopulationIndicator(400, p.height/2, pademelons, "#FF9800", "Pademelons");
        drawPopulationIndicator(600, p.height/2, devils, "#F44336", "Devils");
        drawPopulationIndicator(800, p.height/2, bandicoots, "#FFEB3B", "Bandicoots");
        
        // Draw biodiversity meter
        drawBiodiversityMeter();
      }

      function drawFoodWeb() {
        p.strokeWeight(2);
        
        // Grass ‚Üí Pademelons
        if (grass > 10 && pademelons > 10) {
          p.stroke(0, 150, 0, 150);
          p.line(220, p.height/2, 380, p.height/2);
        }
        
        // Pademelons ‚Üí Devils
        if (pademelons > 10 && devils > 10) {
          p.stroke(150, 0, 0, 150);
          p.line(420, p.height/2, 580, p.height/2);
        }
        
        // Bandicoots ‚Üí Grass (positive feedback)
        if (bandicoots > 10 && grass > 10) {
          p.stroke(255, 255, 0, 150);
          p.drawingContext.setLineDash([5, 3]);
          p.line(780, p.height/2, 250, p.height/2);
          p.drawingContext.setLineDash([]);
        }
      }

      function drawPopulationIndicator(x, y, population, color, label) {
        const size = p.map(population, 0, 1000, 10, 100);
        p.fill(color);
        p.noStroke();
        
        // Draw multiple circles for animal populations
        const count = p.min(10, p.ceil(population / 50));
        for (let i = 0; i < count; i++) {
          const offsetX = p.random(-size/2, size/2);
          const offsetY = p.random(-size/3, size/3);
          p.ellipse(x + offsetX, y + offsetY, size);
        }
        
        // Label
        p.fill(0);
        p.textSize(12);
        p.textAlign(p.CENTER);
        p.text(`${label}: ${p.round(population)}`, x, y + size/2 + 20);
      }

      function drawBiodiversityMeter() {
        const w = 150, h = 20;
        const x = p.width - w - 20, y = 20;
        
        // Background
        p.fill(240);
        p.rect(x, y, w, h);
        
        // Meter
        const meterWidth = w * biodiversityIndex;
        p.fill(p.lerpColor(p.color(255, 0, 0), p.color(0, 255, 0), biodiversityIndex));
        p.rect(x, y, meterWidth, h);
        
        // Text
        p.fill(0);
        p.textSize(12);
        p.textAlign(p.LEFT, p.CENTER);
        p.text(`Biodiversity: ${biodiversityIndex.toFixed(2)}`, x, y + h/2);
      }
    };

    // Create p5 instance
    new p5(sketch);

    function initChart() {
      const ctx = document.getElementById('populationChart').getContext('2d');
      chart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: Array(100).fill().map((_, i) => i),
          datasets: [
            { label: "Grass", data: Array(100).fill(0), borderColor: "#4CAF50", fill: false },
            { label: "Pademelons", data: Array(100).fill(0), borderColor: "#FF9800", fill: false },
            { label: "Devils", data: Array(100).fill(0), borderColor: "#F44336", fill: false },
            { label: "Bandicoots", data: Array(100).fill(0), borderColor: "#FFEB3B", fill: false }
          ]
        },
        options: {
          responsive: true,
          animation: { duration: 0 },
          scales: {
            x: { 
              title: { display: true, text: 'Time' },
              min: 0,
              max: 100
            },
            y: { 
              title: { display: true, text: 'Population' },
              min: 0,
              suggestedMax: 1000
            }
          }
        }
      });
    }

    function initControls() {
      // Speed control
      const speedSlider = document.getElementById("speedSlider");
      const speedValue = document.getElementById("speedValue");
      speedSlider.addEventListener("input", () => {
        speedMultiplier = parseFloat(speedSlider.value);
        speedValue.textContent = speedMultiplier.toFixed(1) + "x";
      });

      // Slider value updates
      document.querySelectorAll("input[type='range']").forEach(slider => {
        slider.addEventListener("input", function() {
          document.getElementById(this.id + 'Value').textContent = this.value;
        });
      });

      // Button events
      document.getElementById("pauseButton").addEventListener("click", togglePause);
      document.getElementById("resetButton").addEventListener("click", resetSim);
      document.getElementById("toggleSeasons").addEventListener("change", toggleSeasonsDisplay);
      document.getElementById("toggleDisasters").addEventListener("change", toggleDisasters);
      document.getElementById("toggleGrassLimitButton").addEventListener("click", toggleGrassLimit);
      document.getElementById("exportCSV").addEventListener("click", exportCSV);
      
      // Collapsible sections
      document.querySelectorAll(".collapsible").forEach(button => {
        button.addEventListener("click", function() {
          this.classList.toggle("active");
          const content = this.nextElementSibling;
          if (content.style.display === "block") {
            content.style.display = "none";
            this.setAttribute("aria-expanded", "false");
          } else {
            content.style.display = "block";
            this.setAttribute("aria-expanded", "true");
          }
        });
      });
    }

    function resetSim() {
      // Reset populations
      grass = 100;
      pademelons = 50;
      devils = 10;
      bandicoots = 30;
      
      // Reset tracking variables
      customFrameCount = 0;
      lastFrameTime = performance.now();
      points = 0;
      ecosystemHealth = 100;
      biodiversityIndex = 0;
      maxGrass = 0;
      maxPademelons = 0;
      maxDevils = 0;
      maxBandicoots = 0;
      
      // Reset objectives
      objectives.forEach(obj => obj.achieved = false);
      ongoingObjectives.forEach(obj => {
        obj.achieved = false;
        obj.target = obj.type === "balanced" ? 1500 : 800;
      });
      achievements.forEach(ach => ach.achieved = false);
      
      // Reset chart
      if (chart) {
        chart.data.labels = Array(100).fill().map((_, i) => i);
        chart.data.datasets.forEach(dataset => dataset.data = Array(100).fill(0));
        chart.update();
      }
      
      populationHistory = [];
      
      // Reset sliders to default
      document.getElementById("rainfall").value = 50;
      document.getElementById("rainfallValue").textContent = "50";
      document.getElementById("temperature").value = 20;
      document.getElementById("temperatureValue").textContent = "20";
      document.getElementById("invasiveSpecies").value = 5;
      document.getElementById("invasiveSpeciesValue").textContent = "5";
      document.getElementById("humanImpact").value = 2;
      document.getElementById("humanImpactValue").textContent = "2";
      
      // Reset season
      season = 0;
      targetRainfall = currentRainfall = seasonParams[season].rainfall;
      targetTemperature = currentTemperature = seasonParams[season].temperature;
      document.getElementById("seasonDisplay").textContent = "Season: " + seasonParams[season].name;
      
      updateUI();
    }

    function gameLoop(timestamp) {
      if (!isPaused) {
        const deltaTime = timestamp - lastFrameTime;
        
        if (deltaTime >= (16 / speedMultiplier)) {
          update();
          customFrameCount++;
          lastFrameTime = timestamp;
        }
      }
      requestAnimationFrame(gameLoop);
    }

    function update() {
      // Seasonal changes
      updateSeasons();
      
      // Get environmental factors
      const rainfall = getModifiedRainfall();
      const temperature = getModifiedTemperature();
      const invasiveSpecies = parseFloat(document.getElementById("invasiveSpecies").value);
      const humanImpact = parseFloat(document.getElementById("humanImpact").value);
      
      // Update populations
      updateGrass(rainfall, invasiveSpecies);
      updatePademelons(temperature, humanImpact, invasiveSpecies);
      updateBandicoots(temperature, invasiveSpecies, humanImpact);
      updateDevils(humanImpact, temperature);
      
      // Apply population limits
      enforceLimits();
      
      // Track history for stability checks
      updateHistory();
      
      // Check for events and objectives
      checkRandomEvents();
      checkObjectives();
      updateEcosystemMetrics();
    }

    function updateSeasons() {
      if (customFrameCount % seasonDuration === 0) {
        season = (season + 1) % 4;
        document.getElementById("seasonDisplay").textContent = `Season: ${seasonParams[season].name}`;
        targetRainfall = seasonParams[season].rainfall;
        targetTemperature = seasonParams[season].temperature;
      }
      
      // Smooth seasonal transitions
      currentRainfall += (targetRainfall - currentRainfall) * interpolationSpeed;
      currentTemperature += (targetTemperature - currentTemperature) * interpolationSpeed;
    }

    function getModifiedRainfall() {
      const rainfallSlider = parseFloat(document.getElementById("rainfall").value) - 50;
      return currentRainfall + rainfallSlider;
    }

    function getModifiedTemperature() {
      const tempSlider = parseFloat(document.getElementById("temperature").value) - 20;
      return currentTemperature + tempSlider;
    }

    function updateGrass(rainfall, invasiveSpecies) {
      // Base growth affected by rainfall and bandicoots (keystone effect)
      const bandicootEffect = 1 + (bandicoots * 0.002); // Bandicoots improve grass growth
      const growthRate = (rainfall / 20) * bandicootEffect;
      
      // Loss from pademelons grazing and invasive species
      const lossRate = (pademelons / 25) + (invasiveSpecies / 2);
      
      // Update grass population
      grass += growthRate - lossRate;
      grass = Math.max(grass, 0);
      
      // Track max grass for objectives
      if (grass > maxGrass) maxGrass = grass;
    }

    function updatePademelons(temperature, humanImpact, invasiveSpecies) {
      // Growth depends on available grass
      const growthRate = grass / 200;
      
      // Losses from predation, environment, and humans
      const predationLoss = devils / 8;
      const tempStress = temperature > 25 ? (temperature - 25) / 10 : 0;
      const humanLoss = humanImpact / 3;
      const invasiveLoss = invasiveSpecies / 8;
      
      pademelons += growthRate - predationLoss - tempStress - humanLoss - invasiveLoss;
      pademelons = Math.max(pademelons, 0);
      
      if (pademelons > maxPademelons) maxPademelons = pademelons;
    }

    function updateBandicoots(temperature, invasiveSpecies, humanImpact) {
      // Bandicoots benefit from grass but compete with pademelons
      const resourceAvailability = (grass / 300) - (pademelons / 400);
      const tempEffect = temperature > 30 ? -(temperature - 30) / 15 : 0;
      
      // Threats from devils and human impact
      const predationRisk = devils / 15;
      const humanThreat = humanImpact / 4;
      const invasiveThreat = invasiveSpecies / 6;
      
      bandicoots += resourceAvailability - predationRisk - humanThreat - invasiveThreat + tempEffect;
      bandicoots = Math.max(bandicoots, 0);
      
      if (bandicoots > maxBandicoots) maxBandicoots = bandicoots;
    }

    function updateDevils(humanImpact, temperature) {
      // Devils primarily depend on pademelons but will scavenge
      const foodAvailability = (pademelons / 70) + (bandicoots / 100);
      
      // Carrying capacity based on available prey
      const carryingCapacity = (pademelons + bandicoots) * 0.4;
      const densityDependence = 1 - (devils / (carryingCapacity + 1));
      
      // Environmental stresses
      const tempStress = Math.abs(temperature - 20) / 15;
      const humanStress = humanImpact / 3;
      
      devils += foodAvailability * densityDependence - tempStress - humanStress;
      devils = Math.max(devils, 0);
      
      if (devils > maxDevils) maxDevils = devils;
    }

    function enforceLimits() {
      // Apply carrying capacities
      if (grassLimitEnabled) grass = Math.min(Math.max(grass, 0), 1500);
      
      // Devils can't exceed prey-based capacity
      const devilCapacity = (pademelons + bandicoots) * 0.5;
      devils = Math.min(devils, devilCapacity);
      
      // Bandicoots have grass-dependent limit
      const bandicootCapacity = grass * 0.15;
      bandicoots = Math.min(bandicoots, bandicootCapacity);
    }

    function updateHistory() {
      // Record current state
      populationHistory.push({
        frame: customFrameCount,
        grass: grass,
        pademelons: pademelons,
        devils: devils,
        bandicoots: bandicoots
      });
      
      // Trim history
      if (populationHistory.length > historyLength) {
        populationHistory.shift();
      }
      
      // Update chart data
      chart.data.labels.push(customFrameCount);
      chart.data.datasets[0].data.push(grass);
      chart.data.datasets[1].data.push(pademelons);
      chart.data.datasets[2].data.push(devils);
      chart.data.datasets[3].data.push(bandicoots);
      
      // Remove oldest data points if we exceed our limit
      if (chart.data.labels.length > 100) {
        chart.data.labels.shift();
        chart.data.datasets.forEach(dataset => dataset.data.shift());
      }
      
      // Update the chart's x-axis range
      chart.options.scales.x.min = chart.data.labels[0];
      chart.options.scales.x.max = chart.data.labels[chart.data.labels.length - 1];
      
      // Update the chart
      chart.update();
    }

    function checkRandomEvents() {
      if (showDisasters && customFrameCount % 1000 === 0 && Math.random() < 0.3) {
        triggerRandomEvent();
      }
      
      // Educational narrative events
      if (customFrameCount % 750 === 0) {
        triggerNarrativeEvent();
      }
    }

    function triggerRandomEvent() {
      const events = [
        { 
          name: "Bushfire", 
          effect: () => {
            grass *= 0.3;
            pademelons *= 0.7;
            devils *= 0.9; // Devils can scavenge after fires
            showEventMessage("Bushfire! Grass and pademelon populations severely impacted.", "#ff5722");
          }
        },
        {
          name: "Devil Facial Tumor Disease",
          effect: () => {
            const diseaseSeverity = Math.random() * 0.4 + 0.3;
            devils *= (1 - diseaseSeverity);
            bandicoots *= (1 + diseaseSeverity * 0.5); // Bandicoots benefit from reduced predation
            showEventMessage(`Devil disease outbreak! ${Math.round(diseaseSeverity * 100)}% of devils affected.`, "#9c27b0");
          }
        },
        {
          name: "Drought",
          effect: () => {
            targetRainfall *= 0.4;
            showEventMessage("Severe drought! Rainfall drastically reduced.", "#2196f3");
          }
        }
      ];
      
      const event = events[Math.floor(Math.random() * events.length)];
      event.effect();
      disasterFrame = customFrameCount;
      
      // Update disaster counters
      const disasterObj = objectives.find(obj => obj.type === "disasters");
      if (disasterObj) disasterObj.count++;
    }

    function triggerNarrativeEvent() {
      const messages = [];
      
      if (grass < 100 && pademelons > 150) {
        messages.push("Overgrazing alert! Pademelons are consuming grass faster than it can regrow.");
      }
      
      if (devils > 100 && pademelons < 80) {
        messages.push("Predator pressure! High devil populations are suppressing pademelon numbers.");
      }
      
      if (bandicoots < 20 && grass > 300) {
        messages.push("Keystone species decline: Low bandicoot numbers may lead to reduced soil health.");
      }
      
      if (messages.length > 0) {
        showNarrativeMessage(messages[Math.floor(Math.random() * messages.length)]);
      }
    }

    function checkObjectives() {
      // Standard objectives
      objectives.forEach(obj => {
        if (obj.achieved) return;
        
        let isAchieved = false;
        switch(obj.type) {
          case "pademelons":
            isAchieved = pademelons >= obj.target;
            break;
          case "apex_stability":
            isAchieved = devils >= obj.target && grass > 400;
            break;
          case "keystone_effect":
            isAchieved = grass >= 150 * obj.target; // 150 is starting grass (100) √ó 1.5
            break;
          case "disasters":
            isAchieved = obj.count >= obj.target;
            break;
          case "biodiversity":
            isAchieved = biodiversityIndex > 0.7 && customFrameCount >= obj.target;
            break;
        }
        
        if (isAchieved) {
          obj.achieved = true;
          points += obj.points;
          showAchievement(obj.description, obj.points);
        }
      });
      
      // Ongoing objectives
      ongoingObjectives.forEach(obj => {
        if (obj.achieved) return;
        
        let conditionMet = false;
        switch(obj.type) {
          case "grass":
            conditionMet = obj.condition(grass);
            break;
          case "devils":
            conditionMet = obj.condition(devils);
            break;
          case "balanced":
            conditionMet = obj.condition(grass, pademelons, devils, bandicoots);
            break;
        }
        
        if (conditionMet) {
          obj.target--;
          if (obj.target <= 0) {
            obj.achieved = true;
            points += obj.points;
            showAchievement(obj.description, obj.points);
          }
        } else {
          // Reset progress if condition fails
          obj.target = obj.type === "balanced" ? 1500 : 800;
        }
      });
      
      // Achievements
      checkAchievements();
    }

    function updateEcosystemMetrics() {
      // Calculate biodiversity index (simplified)
      const total = grass + pademelons + devils + bandicoots;
      if (total > 0) {
        const p1 = grass / total;
        const p2 = pademelons / total;
        const p3 = devils / total;
        const p4 = bandicoots / total;
        biodiversityIndex = 1 - (p1*p1 + p2*p2 + p3*p3 + p4*p4);
      }
      
      // Update ecosystem health display
      updateHealthDisplay();
    }

    function updateHealthDisplay() {
      const healthElement = document.getElementById("ecosystemHealth");
      let healthStatus = "";
      let healthColor = "#4CAF50"; // Green
      
      if (grass === 0 || pademelons === 0 || devils === 0 || bandicoots === 0) {
        healthStatus = "COLLAPSED";
        healthColor = "#F44336"; // Red
      } else if (biodiversityIndex < 0.4) {
        healthStatus = "UNSTABLE";
        healthColor = "#FF9800"; // Orange
      } else {
        healthStatus = "HEALTHY";
      }
      
      healthElement.textContent = `Health: ${healthStatus}`;
      healthElement.style.color = healthColor;
    }

    function updateUI() {
      // Update points display
      document.getElementById("pointsDisplay").textContent = points;
      
      // Update objective display
      updateObjectiveDisplay();
      
      // Check for ranger badge
      if (points >= rangerBadgePoints && !rangerBadgeAchieved) {
        rangerBadgeAchieved = true;
        document.getElementById("rangerBadge").style.display = "block";
        document.getElementById("medalIcon").style.display = "block";
        showAchievement("Congratulations! You've earned the Ranger Badge!", 0);
      }
    }

    function updateObjectiveDisplay() {
      const objectiveDisplay = document.getElementById("objectiveDisplay");
      const nextObj = objectives.find(obj => !obj.achieved) || 
                      ongoingObjectives.find(obj => !obj.achieved);
      
      if (nextObj) {
        objectiveDisplay.textContent = nextObj.description;
        
        // Add progress for ongoing objectives
        if (nextObj.target && nextObj.target !== nextObj.points) {
          const progress = ((nextObj.type === "balanced" ? 1500 : 800) - nextObj.target) / 
                          (nextObj.type === "balanced" ? 1500 : 800) * 100;
          objectiveDisplay.textContent += ` (${Math.round(progress)}% progress)`;
        }
      } else {
        objectiveDisplay.textContent = "All objectives completed! Try for achievements.";
      }
    }

    function showEventMessage(message, color) {
      const eventMsg = document.getElementById("disasterMessage");
      eventMsg.textContent = message;
      eventMsg.style.backgroundColor = color;
      eventMsg.style.display = "block";
      
      setTimeout(() => {
        eventMsg.style.opacity = "0";
        setTimeout(() => {
          eventMsg.style.display = "none";
          eventMsg.style.opacity = "1";
        }, 1000);
      }, 3000);
    }

    function showNarrativeMessage(message) {
      const narrativeElement = document.createElement("div");
      narrativeElement.className = "narrative-message";
      narrativeElement.textContent = message;
      document.body.appendChild(narrativeElement);
      
      setTimeout(() => {
        narrativeElement.style.opacity = "0";
        setTimeout(() => narrativeElement.remove(), 1000);
      }, 5000);
    }

    function showAchievement(message, points) {
      const achievementElement = document.createElement("div");
      achievementElement.className = "achievement-message";
      
      if (points > 0) {
        achievementElement.innerHTML = `<strong>${message}</strong><br>+${points} points`;
      } else {
        achievementElement.innerHTML = `<strong>${message}</strong>`;
      }
      
      document.getElementById("achievementsContainer").appendChild(achievementElement);
      
      setTimeout(() => {
        achievementElement.style.opacity = "0";
        setTimeout(() => achievementElement.remove(), 1000);
      }, 3000);
    }

    function checkAchievements() {
      achievements.forEach(achievement => {
        if (achievement.achieved) return;
        
        let achieved = false;
        
        if (achievement.description.includes("ongoing objectives")) {
          achieved = ongoingObjectives.every(obj => obj.achieved);
        } 
        else if (achievement.description.includes("devil population")) {
          achievement.frames = devils > 70 ? achievement.frames + 1 : 0;
          achieved = achievement.frames >= achievement.target;
        }
        else if (achievement.description.includes("bandicoot population")) {
          achieved = bandicoots >= achievement.target;
        }
        
        if (achieved) {
          achievement.achieved = true;
          points += achievement.points;
          showAchievement(achievement.description, achievement.points);
        }
      });
    }

    // UI control functions
    function togglePause() {
      isPaused = !isPaused;
      document.getElementById("pauseButton").textContent = isPaused ? "Resume" : "Pause";
    }

    function toggleSeasonsDisplay() {
      showSeasons = document.getElementById("toggleSeasons").checked;
    }

    function toggleDisasters() {
      showDisasters = document.getElementById("toggleDisasters").checked;
    }

    function toggleGrassLimit() {
      grassLimitEnabled = !grassLimitEnabled;
      document.getElementById("toggleGrassLimitButton").textContent = 
        grassLimitEnabled ? "Disable Grass Limit" : "Enable Grass Limit";
    }

    function exportCSV() {
      let csvContent = "data:text/csv;charset=utf-8,";
      csvContent += "Time,Grass,Pademelons,Devils,Bandicoots\n";
      
      chart.data.labels.forEach((time, i) => {
        csvContent += `${time},${chart.data.datasets[0].data[i]},${chart.data.datasets[1].data[i]},${chart.data.datasets[2].data[i]},${chart.data.datasets[3].data[i]}\n`;
      });
      
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "ecosystem_data.csv");
      link.textContent = "Download CSV";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    function updateValue(id) {
      document.getElementById(id + 'Value').textContent = document.getElementById(id).value;
    }

    // Initialize when page loads
    window.addEventListener('DOMContentLoaded', (event) => {
      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          togglePause();
        }
      });
    });
  </script>

  <!-- Global function for quiz answers -->
  <script>
    function showAnswer(id) {
      const answer = document.getElementById(id);
      answer.style.display = answer.style.display === 'none' ? 'block' : 'none';
    }
  </script>

  <footer>
    Created by Jay Rowley 2025
  </footer>
</body>
</html>
